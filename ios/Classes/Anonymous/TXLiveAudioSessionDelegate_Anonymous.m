//////////////////////////////////////////////////////////
// GENERATED BY FLUTTIFY. DO NOT EDIT IT.
//////////////////////////////////////////////////////////

#import "TXLiveAudioSessionDelegate_Anonymous.h"
#import <Flutter/Flutter.h>
#import "FluttifyMessageCodec.h"
#import <objc/runtime.h>

// Dart端一次方法调用所存在的栈, 只有当MethodChannel传递参数受限时, 再启用这个容器
extern NSMutableDictionary<NSString*, NSObject*>* STACK;
// Dart端随机存取对象的容器
extern NSMutableDictionary<NSString*, NSObject*>* HEAP;
// 日志打印开关
extern BOOL enableLog;

@implementation TXLiveAudioSessionDelegate_Anonymous

- (instancetype) initWithFlutterPluginRegistrar: (NSObject <FlutterPluginRegistrar> *) registrar {
  self = [super init];
  if (self) {
    _registrar = registrar;
  }

  return self;
}

- (BOOL)setActive : (BOOL)active error: (NSError**)outError
{
  FlutterMethodChannel *channel = [FlutterMethodChannel
        methodChannelWithName:[NSString stringWithFormat:@"TXLiveAudioSessionDelegate::Callback@%@:%@", NSStringFromClass([self class]), @(self.hash)]
              binaryMessenger:[_registrar messenger]
                        codec:[FlutterStandardMethodCodec codecWithReaderWriter:[[FluttifyReaderWriter alloc] init]]];
  // print log
  if (enableLog) {
    NSLog(@"TXLiveAudioSessionDelegate::setActive_error");
  }

  // convert to jsonable arg
  

  dispatch_async(dispatch_get_main_queue(), ^{
    [channel invokeMethod:@"setActive_error"
                arguments:@{@"active": argactive == nil ? [NSNull null] : argactive, @"outError": argoutError == nil ? [NSNull null] : argoutError}
                   result:^(id result) {}]; // 由于结果是异步返回, 这里用不上, 所以就不生成代码了
  });
  
  // 由于flutter无法同步调用method channel, 所以暂不支持有返回值的回调方法
  // 相关issue https://github.com/flutter/flutter/issues/28310
  NSLog(@"暂不支持有返回值的回调方法");
  
  ////////////////////////////如果需要手写代码, 请写在这里/////////////////////////////
  
  ////////////////////////////////////////////////////////////////////////////////
  
  return NO;
}

- (BOOL)setMode : (NSString*)mode error: (NSError**)outError
{
  FlutterMethodChannel *channel = [FlutterMethodChannel
        methodChannelWithName:[NSString stringWithFormat:@"TXLiveAudioSessionDelegate::Callback@%@:%@", NSStringFromClass([self class]), @(self.hash)]
              binaryMessenger:[_registrar messenger]
                        codec:[FlutterStandardMethodCodec codecWithReaderWriter:[[FluttifyReaderWriter alloc] init]]];
  // print log
  if (enableLog) {
    NSLog(@"TXLiveAudioSessionDelegate::setMode_error");
  }

  // convert to jsonable arg
  

  dispatch_async(dispatch_get_main_queue(), ^{
    [channel invokeMethod:@"setMode_error"
                arguments:@{@"mode": argmode == nil ? [NSNull null] : argmode, @"outError": argoutError == nil ? [NSNull null] : argoutError}
                   result:^(id result) {}]; // 由于结果是异步返回, 这里用不上, 所以就不生成代码了
  });
  
  // 由于flutter无法同步调用method channel, 所以暂不支持有返回值的回调方法
  // 相关issue https://github.com/flutter/flutter/issues/28310
  NSLog(@"暂不支持有返回值的回调方法");
  
  ////////////////////////////如果需要手写代码, 请写在这里/////////////////////////////
  
  ////////////////////////////////////////////////////////////////////////////////
  
  return NO;
}

- (BOOL)setCategory : (NSString*)category error: (NSError**)outError
{
  FlutterMethodChannel *channel = [FlutterMethodChannel
        methodChannelWithName:[NSString stringWithFormat:@"TXLiveAudioSessionDelegate::Callback@%@:%@", NSStringFromClass([self class]), @(self.hash)]
              binaryMessenger:[_registrar messenger]
                        codec:[FlutterStandardMethodCodec codecWithReaderWriter:[[FluttifyReaderWriter alloc] init]]];
  // print log
  if (enableLog) {
    NSLog(@"TXLiveAudioSessionDelegate::setCategory_error");
  }

  // convert to jsonable arg
  

  dispatch_async(dispatch_get_main_queue(), ^{
    [channel invokeMethod:@"setCategory_error"
                arguments:@{@"category": argcategory == nil ? [NSNull null] : argcategory, @"outError": argoutError == nil ? [NSNull null] : argoutError}
                   result:^(id result) {}]; // 由于结果是异步返回, 这里用不上, 所以就不生成代码了
  });
  
  // 由于flutter无法同步调用method channel, 所以暂不支持有返回值的回调方法
  // 相关issue https://github.com/flutter/flutter/issues/28310
  NSLog(@"暂不支持有返回值的回调方法");
  
  ////////////////////////////如果需要手写代码, 请写在这里/////////////////////////////
  
  ////////////////////////////////////////////////////////////////////////////////
  
  return NO;
}

- (BOOL)setPreferredIOBufferDuration : (NSTimeInterval)duration error: (NSError**)outError
{
  FlutterMethodChannel *channel = [FlutterMethodChannel
        methodChannelWithName:[NSString stringWithFormat:@"TXLiveAudioSessionDelegate::Callback@%@:%@", NSStringFromClass([self class]), @(self.hash)]
              binaryMessenger:[_registrar messenger]
                        codec:[FlutterStandardMethodCodec codecWithReaderWriter:[[FluttifyReaderWriter alloc] init]]];
  // print log
  if (enableLog) {
    NSLog(@"TXLiveAudioSessionDelegate::setPreferredIOBufferDuration_error");
  }

  // convert to jsonable arg
  

  dispatch_async(dispatch_get_main_queue(), ^{
    [channel invokeMethod:@"setPreferredIOBufferDuration_error"
                arguments:@{@"duration": argduration == nil ? [NSNull null] : argduration, @"outError": argoutError == nil ? [NSNull null] : argoutError}
                   result:^(id result) {}]; // 由于结果是异步返回, 这里用不上, 所以就不生成代码了
  });
  
  // 由于flutter无法同步调用method channel, 所以暂不支持有返回值的回调方法
  // 相关issue https://github.com/flutter/flutter/issues/28310
  NSLog(@"暂不支持有返回值的回调方法");
  
  ////////////////////////////如果需要手写代码, 请写在这里/////////////////////////////
  
  ////////////////////////////////////////////////////////////////////////////////
  
  return NO;
}

- (BOOL)setPreferredSampleRate : (double)sampleRate error: (NSError**)outError
{
  FlutterMethodChannel *channel = [FlutterMethodChannel
        methodChannelWithName:[NSString stringWithFormat:@"TXLiveAudioSessionDelegate::Callback@%@:%@", NSStringFromClass([self class]), @(self.hash)]
              binaryMessenger:[_registrar messenger]
                        codec:[FlutterStandardMethodCodec codecWithReaderWriter:[[FluttifyReaderWriter alloc] init]]];
  // print log
  if (enableLog) {
    NSLog(@"TXLiveAudioSessionDelegate::setPreferredSampleRate_error");
  }

  // convert to jsonable arg
  

  dispatch_async(dispatch_get_main_queue(), ^{
    [channel invokeMethod:@"setPreferredSampleRate_error"
                arguments:@{@"sampleRate": argsampleRate == nil ? [NSNull null] : argsampleRate, @"outError": argoutError == nil ? [NSNull null] : argoutError}
                   result:^(id result) {}]; // 由于结果是异步返回, 这里用不上, 所以就不生成代码了
  });
  
  // 由于flutter无法同步调用method channel, 所以暂不支持有返回值的回调方法
  // 相关issue https://github.com/flutter/flutter/issues/28310
  NSLog(@"暂不支持有返回值的回调方法");
  
  ////////////////////////////如果需要手写代码, 请写在这里/////////////////////////////
  
  ////////////////////////////////////////////////////////////////////////////////
  
  return NO;
}

- (BOOL)setPreferredOutputNumberOfChannels : (NSInteger)count error: (NSError**)outError
{
  FlutterMethodChannel *channel = [FlutterMethodChannel
        methodChannelWithName:[NSString stringWithFormat:@"TXLiveAudioSessionDelegate::Callback@%@:%@", NSStringFromClass([self class]), @(self.hash)]
              binaryMessenger:[_registrar messenger]
                        codec:[FlutterStandardMethodCodec codecWithReaderWriter:[[FluttifyReaderWriter alloc] init]]];
  // print log
  if (enableLog) {
    NSLog(@"TXLiveAudioSessionDelegate::setPreferredOutputNumberOfChannels_error");
  }

  // convert to jsonable arg
  

  dispatch_async(dispatch_get_main_queue(), ^{
    [channel invokeMethod:@"setPreferredOutputNumberOfChannels_error"
                arguments:@{@"count": argcount == nil ? [NSNull null] : argcount, @"outError": argoutError == nil ? [NSNull null] : argoutError}
                   result:^(id result) {}]; // 由于结果是异步返回, 这里用不上, 所以就不生成代码了
  });
  
  // 由于flutter无法同步调用method channel, 所以暂不支持有返回值的回调方法
  // 相关issue https://github.com/flutter/flutter/issues/28310
  NSLog(@"暂不支持有返回值的回调方法");
  
  ////////////////////////////如果需要手写代码, 请写在这里/////////////////////////////
  
  ////////////////////////////////////////////////////////////////////////////////
  
  return NO;
}


@end
